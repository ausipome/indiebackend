"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ensureDatabaseExists_exports = {};
__export(ensureDatabaseExists_exports, {
  askToCreateDb: () => askToCreateDb,
  ensureCanConnectToDatabase: () => ensureCanConnectToDatabase,
  ensureDatabaseExists: () => ensureDatabaseExists,
  getDbInfo: () => getDbInfo,
  getDbLocation: () => getDbLocation,
  getDbinfoFromCredentials: () => getDbinfoFromCredentials,
  interactivelyCreateDatabase: () => interactivelyCreateDatabase
});
module.exports = __toCommonJS(ensureDatabaseExists_exports);
var import_internals = require("@prisma/internals");
var import_chalk = __toESM(require("chalk"));
var import_prompts = __toESM(require("prompts"));
async function getDbInfo(schemaPath) {
  var _a;
  const datamodel = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel });
  const activeDatasource = (_a = config.datasources) == null ? void 0 : _a[0];
  if (!activeDatasource) {
    return {
      name: void 0,
      schemaWord: "database",
      dbType: void 0,
      dbName: void 0,
      dbLocation: void 0,
      url: void 0
    };
  }
  const url = activeDatasource.url.value;
  if (activeDatasource.provider === "sqlserver") {
    return {
      name: activeDatasource.name,
      schemaWord: "database",
      dbType: "SQL Server",
      dbName: void 0,
      dbLocation: void 0,
      url: activeDatasource.url.value
    };
  }
  try {
    const credentials = (0, import_internals.uriToCredentials)(url);
    const dbLocation = getDbLocation(credentials);
    const dbinfoFromCredentials = getDbinfoFromCredentials(credentials);
    const dbInfo = {
      name: activeDatasource.name,
      dbLocation,
      ...dbinfoFromCredentials,
      url,
      schema: credentials.schema
    };
    if (activeDatasource.provider === "cockroachdb") {
      dbInfo.dbType = "CockroachDB";
    }
    return dbInfo;
  } catch (e) {
    return {
      name: activeDatasource.name,
      schemaWord: "database",
      dbType: void 0,
      dbName: void 0,
      dbLocation: void 0,
      url
    };
  }
}
__name(getDbInfo, "getDbInfo");
async function ensureCanConnectToDatabase(schemaPath) {
  const datamodel = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel });
  const activeDatasource = config.datasources[0];
  if (!activeDatasource) {
    throw new Error(`Couldn't find a datasource in the schema.prisma file`);
  }
  const schemaDir = await (0, import_internals.getSchemaDir)(schemaPath);
  const canConnect = await (0, import_internals.canConnectToDatabase)(activeDatasource.url.value, schemaDir);
  if (canConnect === true) {
    return true;
  } else {
    const { code, message } = canConnect;
    throw new Error(`${code}: ${message}`);
  }
}
__name(ensureCanConnectToDatabase, "ensureCanConnectToDatabase");
async function ensureDatabaseExists(action, forceCreate = false, schemaPath) {
  const datamodel = await (0, import_internals.getSchema)(schemaPath);
  const config = await (0, import_internals.getConfig)({ datamodel });
  const activeDatasource = config.datasources[0];
  if (!activeDatasource) {
    throw new Error(`Couldn't find a datasource in the schema.prisma file`);
  }
  const schemaDir = await (0, import_internals.getSchemaDir)(schemaPath);
  const canConnect = await (0, import_internals.canConnectToDatabase)(activeDatasource.url.value, schemaDir);
  if (canConnect === true) {
    return;
  }
  const { code, message } = canConnect;
  if (code !== "P1003") {
    throw new Error(`${code}: ${message}`);
  }
  if (!schemaDir) {
    throw new Error(`Could not locate ${schemaPath || "schema.prisma"}`);
  }
  if (forceCreate) {
    if (await (0, import_internals.createDatabase)(activeDatasource.url.value, schemaDir)) {
      if (activeDatasource.provider === "sqlserver") {
        return `SQL Server database created.
`;
      }
      const credentials = (0, import_internals.uriToCredentials)(activeDatasource.url.value);
      const { schemaWord, dbType, dbName } = getDbinfoFromCredentials(credentials);
      let databaseProvider = dbType;
      if (dbType && dbType !== "SQL Server") {
        if (activeDatasource.provider === "cockroachdb") {
          databaseProvider = "CockroachDB";
        }
        return `${databaseProvider} ${schemaWord} ${import_chalk.default.bold(dbName)} created at ${import_chalk.default.bold(
          getDbLocation(credentials)
        )}`;
      } else {
        return `${schemaWord} created.`;
      }
    }
  } else {
    await interactivelyCreateDatabase(activeDatasource.url.value, action, schemaDir);
  }
  return void 0;
}
__name(ensureDatabaseExists, "ensureDatabaseExists");
async function interactivelyCreateDatabase(connectionString, action, schemaDir) {
  await askToCreateDb(connectionString, action, schemaDir);
}
__name(interactivelyCreateDatabase, "interactivelyCreateDatabase");
async function askToCreateDb(connectionString, action, schemaDir) {
  const credentials = (0, import_internals.uriToCredentials)(connectionString);
  const { schemaWord, dbType, dbName } = getDbinfoFromCredentials(credentials);
  const dbLocation = getDbLocation(credentials);
  let message;
  if (dbName && dbLocation) {
    message = `You are trying to ${action} a migration for ${dbType} ${schemaWord} ${import_chalk.default.bold(
      dbName
    )}.
A ${schemaWord} with that name doesn't exist at ${import_chalk.default.bold(dbLocation)}.
`;
  } else {
    message = `You are trying to ${action} a migration for ${dbType} ${schemaWord}.
The ${schemaWord} doesn't exist.
`;
  }
  console.info();
  const response = await (0, import_prompts.default)({
    type: "select",
    name: "value",
    message,
    initial: 0,
    choices: [
      {
        title: "Yes",
        value: true,
        description: `Create new ${dbType} ${schemaWord} ${import_chalk.default.bold(dbName)}`
      },
      {
        title: "No",
        value: false,
        description: `Don't create the ${schemaWord}`
      }
    ]
  });
  if (response.value) {
    await (0, import_internals.createDatabase)(connectionString, schemaDir);
  } else {
    process.exit(130);
  }
}
__name(askToCreateDb, "askToCreateDb");
function getDbLocation(credentials) {
  if (credentials.type === "sqlite") {
    return credentials.uri;
  }
  if (!credentials.port) {
    switch (credentials.type) {
      case "mysql":
        credentials.port = 3306;
        break;
      case "postgresql":
        credentials.port = 5432;
        break;
      case "sqlserver":
        credentials.port = 1433;
        break;
    }
  }
  return `${credentials.host}:${credentials.port}`;
}
__name(getDbLocation, "getDbLocation");
function getDbinfoFromCredentials(credentials) {
  const dbName = credentials.database;
  let dbType;
  switch (credentials.type) {
    case "mysql":
      dbType = `MySQL`;
      break;
    case "postgresql":
      dbType = `PostgreSQL`;
      break;
    case "sqlite":
      dbType = `SQLite`;
      break;
    case "cockroachdb":
      dbType = `CockroachDB`;
      break;
    case "sqlserver":
      dbType = `SQL Server`;
      break;
  }
  const schemaWord = "database";
  return {
    dbName,
    dbType,
    schemaWord
  };
}
__name(getDbinfoFromCredentials, "getDbinfoFromCredentials");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  askToCreateDb,
  ensureCanConnectToDatabase,
  ensureDatabaseExists,
  getDbInfo,
  getDbLocation,
  getDbinfoFromCredentials,
  interactivelyCreateDatabase
});
